# PHP подкаст #11

Новый стабильный PHP7.1, Symfony 3.2, дедупликации кеша, React вместо Twig’а, сериализуем руками, RabbitMQ для масштабирования и немного еще с Symfoniacs #10

Главная новость недели — [выход](http://php.net/releases/7_1_0.php) новой стабильной версии интерпретатора PHP 7.1. Миновало 6 RC и в обозначенный срок вышла новая стабильная версия.

Коротко обозначу новые фичи:
* function test(): ?int // nullable type
* function test(): void // void return type
* function test(): iterable // iterable pseudo-type
* if (is_iterable($sth)) { //…
* private const GRUMPY_CONST = 666; // constant visibility
* [«a» => $a, «b» => $b, «c» => $c] = [«a» => 1, «b» => 2, «c» => 3]; // list() -> []
* } catch (Exception1  | Exception2 $e) { //…

[Встречайте](http://symfony.com/blog/symfony-3-2-0-released) очередную стабильную версию Symfony 3.2. Перейти на неё очень просто, если вы уже на 3+ версии. Большинство нововведений о введении deprecations, которые будут бросать исключения в Symfony 4. В 3.2 единственным новым компонентом будет Worflow, реализующий сети Петри. Мы обсуждали их в одном из предыдущих подкастов.

Вы, наверное, обратили внимание, что я часто говорю о Symfony и не так часто о других фреймворках. На мой взгляд разработчики из Sensio labs ухватили из других экосистем важнейшие моменты раньше остальных в PHP-мире: микроядро/микрофреймворк, компоненты, которые можно более-менее легко замещать другими, отличная документация (в противовес бедной Zend Framework и не фредли на момент 2-3 летней давности). Тем не менее я хочу чтобы справедливость торжествовала и если вы хотите представлять в этом подкасте другие фреймворки, то прошу присоединяться. Я за разнообразие и конкуренцию.

Первая [статья](https://habrahabr.ru/company/google/blog/316344/) о кешировании и тех проблемах, с которыми вы можете столкнуться: отсутствие дедупликации при обращении к кешу, кешируемый источник ненадежен. Статья рекламирует Google AppEngine и поэтому в большей степени ориентирована на реализацию на этой платформе. Главная идея статьи: недоверяйте никому. Ни вашему кешу, ни тому, что источник данных для кеша надежен, ни своим пользователям :).

В предыдущем подкасте я говорил о PHPChunkit — утилите для параллельного выполнения тестов. Я же чаще использую paratest (на него есть [линк с сайта PHPUnit](https://phpunit.de/plugins.html), а также он поддерживается LiipFunctionalTestBundle) и заметил следующий баг: исключив все группы тесты крашатся. Станьте супергероем и сделайте PR.

Короткая [заметка](http://blog.doh.ms/2016/11/28/solving-conflicts-in-composer-lock/) о том, как резловить конфликты в composer.lock файле. Идея в том, что не надо резолвить руками. Просто чекаутитесь на предыдущую версию и запускаете composer require / update.

## Обзор [Symfoniacs #10 митапа](https://www.meetup.com/Symfoniacs/events/235412035/)

Глеб Тильтиков рассказал о дизайн паттернах в Symfony-фреймворке. С UML диаграммами и примерами. Упомянул следующие паттерны:

* Front Controller;
* Command (Command Component);
* Facade (контроллер в MVC);
* Chain of responsibility (Service container);
* Factory method;
* Strategy pattern (стратегии хранения данных для Profiler’а);
* Builder (Form Builder);
* Lazy initialization;
* Object Pool (Service container);
* Adapter (*Adapter классы);
* Bridge;
* Decorator (кеширование в HttpKernel);
* Mediator (EventDispatcher компонент);

Если вы не поняли отличий Bridge от адаптера или от стратегии, то целью видео и не было дать ясное понимание разницы.

Алексей Кузнецов (8bit) [рассказал](https://www.youtube.com/watch?v=C4PPvRSHamE) про AMQP и RabbitMQ для улучшения масштабирования проекта. AMQP может быть использован для взаимодействия микросервисов в микросервисной архитектуре. Предположим, что задача состоит из следующих шагов:

* принять данные;
* валидировать данные;
* обновить статистику;
* вызвать внешнее API (например, для передачи данных).

При стандартных монолитных подходах это все делает в одном рантайме. Следующий возможный шаг оптимизации — добавить cron-задачи. Используя же AMQP можно в рантайме выполнить только первые два шага и отдать остальные задачи в очередь. Любопытная опция x-dead-letter-exchange для задания обработчика необработанных сообщений. Можно задавать задержку при помощи x-message-ttl.

Илья Сычев и Алексей Деменьтев (Rambler) [затронули](https://www.youtube.com/watch?v=kqU-qbW_F9o) тему замены TWIG’а на REACT. Проблема возникает, когда есть необходимость дублировать верстку. Т.е. в одном месте некий виджет рендерится Twig’ом, а в другом должен быть почти таким же, но на реакте. Решение — рендерить на бэкенде на NodeJS.

В этом же видео Кирилл Несмеянов (Rambler) рассказал о стеке для реализации эффективного API. Простой подход — который чаще всего встречается в проектах — это JMS + Doctrine (+ Nelmio для документации). При этом у JMS есть ряд недостатков: медленно, жадные запросы в БД, умеет работать с объектами (через листерены можно добавлять атрибуты, но это скорее костыль). Предложенный путь: брать данные и применять к ним слой презентации и его валидировать.

Никита Самохвалов [рассказал](https://www.youtube.com/watch?v=m6YIqH2q0Tw) про оркестрирование приложений. Но начал с важных вещей: документация до кода, планирование архитектуры. Понравилась идея про смену ролей разработчиков. Периодически разработчики помогают в процессе релиза и отлова багов (документирования багов). Если вы хотите обезопаситься от проблем доступности packagist или недоступности каких-то версий пакетов, то можно использовать [satis](https://github.com/composer/satis) или [toran proxy](https://toranproxy.com/) (коммерческое решение). Использование GitLab для деплоя.