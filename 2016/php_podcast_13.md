# PHP подкаст #13

Command паттерн, HAL для API, Varnish и Си спешит на помощь.

Command паттерн используется для абстрагирования от технических деталей в пользу бизнес логики. Команду можно формировать из HTTP запроса, введенных данных в CLI и т.д. Команда содержит все необходимые данные для её обработки. Command Bus паттерн также способствует упрощению кода путем инкапсуляции:
1. Бизнес-логика перемещается в специальные хэндлеры и становится независимой от фреймворка (разлепляемся с реквестом, например).
2. Тонкий контроллер.
3. Упрощается тестирование.
4. Меньше дублирования кода.
5. Пространство для маневра за счет middleware (Decoration / Chain of responsibility).
6. Восстановление состояния системы за счет выполнения залогированных ранее команд.

Использование Command Bus особенно удобно в присутствии Service Layer, что предполагает скорее крупное приложение, чем небольшое. Часто — но не обязательно — мы говорим о Command Bus в контексте CQRS. Другим преимуществом Command Bus является разделение вызова и обработчика, что способствует последующему масштабированию — обработчик команды можно вынести за периметр приложения. Этот паттерн в некотором смысле также гарантирует перетекание ненужных зависимостей от фреймворка в бизнес-логику.

Реализаций командных шин предостаточно. Самые популярные:
1. Command Bus / Laravel Collective.
2. Tactician от The PHP League.
3. SimpleBus/MessageBus.
4. ProophServiceBus.

Команда (Command) — это как правило объект с публичным атрибутами, своеобразный DTO. Здесь гармонично смотрятся get/set-методы. В командный объект целесообразно, например, мэпить реквест посредством форм-компонента или путем десериализации.

В middleware вы можете выполнять валидацию, логирование, проверку на достаточность полномочий для выполнения команды, оборачивать выполнение команды в транзакцию и многое другое.

Стоит также упомянуть, что помимо Command Bus существует так называемый Event Bus. Главное отличие второго — можно одно событие обрабатывать \d* обработчиками. Фактически, в качестве Event Bus можно использовать любой Event Dispatcher компонент.

Каков он, [идеальный пакет](http://php-pds.com/)? Очередное предложение о том, как организовать true пакет:

```
bin/            # command-line executables
config/         # configuration files
docs/           # documentation and examples
public/         # web server files
src/            # source code
tests/          # test code
vendor/         # reserved for package managers
CHANGELOG       # a log of changes between releases
CONTRIBUTING    # guidelines for contributors
LICENSE         # licensing information
README          # information about the package itself
```

Не хватает var папки для логов и кеша, например, но в целом ничего. Примерно так многие и делают. А вы пишите доки?)

Everpot [рассказал](https://evertpot.com/working-with-hal-in-put/) о их опыте использования [HAL](http://stateless.co/hal_specification.html) (Hypertext Application Language) и “трюке”. Но я затрону сам HAL для API. В hal+json помимо стандартного payload есть еще _links, содержащий релевантные ссылки. При помощи _links происходит описание связей текущей сущности с другими. Например, в ответ на GET-запрос о данных пользователя мы получаем _links, содержащий ссылки на группы, в которых он состоит. Использование HAL может упростить клиентам жизнь: выше информативность ответов.

Александр Лисаченко [поделился](http://www.slideshare.net/lisachenko/handling-10k-requests-per-second-with-symfony-and-varnish) опытом приготовления Varnish — кеширующий реверс-прокси. Рецепт примерно такой: читаем RFC 7232-7234, ставим Varnish, используем ESI (Edge-Side Includes) / render_esi и [FOSHttpCache](https://github.com/FriendsOfSymfony/FOSHttpCache) (опционально).

Не знаете как провести новый год? Конечно жа [за книгой от Бенджамина Эберлея](https://qafoo.com/blog/093_free_ebook_for_christmas.html) и других из Qafoo! Книга — это собрание их блог постов. Распространяется бесплатно. В книге затронуты темы объектно-ориентированного дизайна (переиспользование кода), тестирования (PHPUnit, Phake, Mink, фикстуры), рефакторинга, воркфлоу (автоматический деплой). 174 страницы!

На хабре [небольшой каминг аут](https://habrahabr.ru/company/badoo/blog/317442/) от Badoo. Интересно почитать коментарии. Прекрасно, что они также вкладываются в няшный Golang.

И в завершение и на закуску замечательная статья для тех, кому не безразлично как все устроено “под капотом”. Признаемся, что мы не занимаемся системным программирование, не часто заглядываем в C-код и еще реже вспоминаем про ассемблер. [Статья](http://jpauli.github.io/2016/11/30/on-c-performances.html) Джульена Паули может стать отличным введением в мир низкоуровнего программирования. Как бы я хотел эту статью прочитать, когда увлекался книгами Юрова и писал экспериментальные вирусы. Автор на примере простой программы — суммирует побайтово 1Гб файл и сохраняет результат суммирования в 8-битном беззнаковом числе (unsigned char) — показывает как используя современные инструкции процессора повысить производительность с 3.5 сек до 0.5 сек. Суммирование файла размером в 1Гб за 0.5 сек. Отличный результат. В случае PHP разработки нужно же помнить, что C/C++ — программисты могут нам здорово помочь. В крупных компаниях они пишут всевозможные расширения для PHP, повышая производительность в узких местах. В любом случае эта статья отлично пойдет вечерком под зеленый чай. На хабре публиковался перевод, но оригинал читается легко. Кстати, в блоге Джульена статей не так много, но они занимательные.

Качайте скилы! До встречи через неделю.